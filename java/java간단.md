#Java
- equals메소드는 참조변수에 저장된 주소값이 같은지 판단한다
- 해시코드는 객체의 주소값을 이용해서 해시코드를 만들어서 반환하기 때문에 한번의 실행에서 서로다른 두 객체는 같은 해시코드를 가질 수 없다
- clone메소드를 사용하기위해서는 Coloneable 인터페이스를 구현해야한다
- 배열을 복사하는 두가지 방법 : clone()메소드, arraycopy()메소드
- 참조변수에 String을 더하면 참조변수가 가리키고있는 인스턴스의 toString()을 호출하여 String을 얻은 다음 결합한다
- String클래스는 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없다.
- StringBuffer에 담긴 문자열을 비교하기 위한 방법은?
 - StringBuffer은 equals를 오버라이딩하지않았다.
 - 하지만 toString은 오버라이딩했고, 담고있는 문자열을 반환한다
 - StringBuffer에 담긴 문자열을 비교하기 위해서 SringBuffer인스턴스에 toString을 호출해서 Sting인스턴스를 얻은다음 여기에 equlas메소드를 사용해서 비교한다
- 기본형 변수를 객체로 다루기 위해 사용하는 클래스 : wrapper
- 내부클래스란 클래스내에 선언된 클래스이다.두 클래스가 긴밀한 관계에 있을 때 사용한다. 내부클래스에서 외부클래스의 멤버들을 쉽게 접근할 수 있고 코드의 복잡성을 줄일 수 있다
- 지역클래스에서 사용할 수 있는 멤버는 무엇이 있는가? 외부클래스의 인스턴스멤버,static멤버,final이 붙은 지역클래스가 포함된 메소드에 정의된 지역변수
- 이 코드의 출력 값은? **30 20 10**
```java
class Outer {
	int value=10;				

	class Inner {
		int value=20;	
		void method1() {
			int value=30;
			System.out.println(value);
			System.out.println(this.value);
			System.out.println(Outer.this.value);
		}
	} // Inner클래스의 끝
} // Outer클래스의 끝

class InnerEx5 {
	public static void main(String args[]) {
		Outer outer = new Outer();
		Outer.Inner inner = outer.new Inner();
		inner.method1();
	}
} // InnerEx5 끝
```

- 익명클래스는 이름이 없는 클래스로 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용할 수 있고, 하나의 객체만 생성할 수 있는 일회용 클래스이다
- List 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다
- Set 순서를 유지하지 않는 데이터집합, 데이터의 중복을 허용하지 않는다
- Map 키와 값의 쌍으로 이루어진 데이터 집합. 순서는 유지되지않으며 키는 중복을 허용하지않고 값은 중복을 허용한다.
- Vector와 Hashtable은 기존 컬렉션 클래스의 호환을 위해 남겨었지만 ArrayList와 HashMap으로 사용하는 것이 좋다.
- 상속관계에서 생성자와 초기화 블럭은 상속되지않는다. 멤버만 상속된다.
- 자손클래스의 멤버개수는 조상클래스보다 많다.
- 단일 상속은 하나의 조상클래스만 가질 수 있기 때문에 클래스 간의 관계가 보다 명확해진다.
- 배열의 단점
 - 크기를 변경할 수 없다
 - 새로운 배열을 생성해서 데이터를 복사해야하고, 실행속도향상을 위해서는 충분히 큰 크기의 배열을 생성해야하기 때문에 메모리 낭비가 있다
 - 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다
 - 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만 배열의 중간에 데이터를 추가하면 빈자리를 만들기 위해 다른 데이터를 복사해서 이동해야한다.
- 트리는 저장하는데에는 시간이 걸리지만 검색과 정렬기능은 뛰어난 자료구조이다.
- 트리는 데이터를 순차적으로 저장하는 것이 아니라 저장위치를 찾아서 저장해야하고 삭제하는 경우 트리의 일부를 재구성해야하므로 링크드리스트보다 데이터의 추가삭제 시간은 더 걸린다.

###Hashtable 클래스, HashMap 클래스

컬렉션 프레임워크와 컬렉션 인터페이스는 자바1.2에서 처음등장했지만, Hashtable클래스와 Vector클래슨느 초기 버전부터 자바의 일부였다.
이 클래스들은 프레임워크를 염두하고 작성된 것이 아니기 때문에 컬렉션 프레임 워크가 포함되었을 때 Hashtable클래스는 Collection인터페이스에 맞게 재단장했다.

Hashtable 클래스는 동기화할 수 있으며 병렬 처리에 효율적이다. 하지만 어떤 단일 스레드 작업이든 오버페드 때문에 성능이 저하된다.
HashMap은 동기화 할 수 없다. 그래서 개발자는 동시성 요구와 용도에 맞게 이 클래스의 사용을 맞춰야 한다.
병렬 환경에서 Map인터페이스를 사용하는 곳에는 ConcrrentHashMap 클래스를 사용하는 것이 좋다.

###LinkedHashMap
기본적으로 HashMap속성을 가지고있다. 키 인덱스를 빠르게 찾을 수 있고, 맵 안 원소들의 순서도 보존한다.

- comparator comparable : 객체들을 정렬 또는 이진검색트리를 구성하는데 필요한 메서드를 정의한 인터페이스

###해싱이란?
해시함수를 이용해서 데이터를 해시테이블에 저장하고 검색하는 기법
해시함수는 데이터가 저장되어있는 곳을 알려준다

##해싱의 과정
- 검색하고자 하는 값의 키로 해시함수를 호출한다
- 해시함수의 계산결과인 해시코드를 이용해서 해당 값이 저장되어있는 링크드리스트를 찾는다
- 링크드리스트에서 검색한 키와 일치하는 데이터를 찾는다

###Properties의 특징
주로 어플리케이션의 환경설정과 관련된 속성을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공한다
Hashtable을 상속받아 구현한 것으로 String String형태로 키와 값을 저장한다

- StringTokenizer : 긴 문자열을 지정된 구분자를 기준으로 토큰이라는 여러개의 작은 문자열로 잘라내는 것
