#프로세스 스케줄링
- 멀티 프로그래밍 - 여러 개의 프로세스를 메모리에 적재하여 실행중이던 프로세스가 CPU 동작이 아닌 다른 이벤트(입출력 동작)가 발생하기를 기다리는 동안 다른 프로세스가  CPU에 의해 실행되도록하여 CPU의 이용율을 최대화하는 개념 
다중 프로그래밍 환경에서는 실행 상태에 있던 프로세스의 실행이 종료되거나 다른 이벤트가 발생하기를 기다리기 위해 대기 상태로 가게되면 실행할 새로운 프로세스를 정해야 함
###좋은 스케쥴링의 기준
- 공정성 - 모든 프로세스들이 공정하게 CPU 시간과 입출력 시간을 할당. 임의의 프로세스가 실행되지 못하고 무한대기하면 안됨
- CPU 이용률 - 주어진 시간 내에 CPUrk 동작하는 시간의 비율로 높아야 함
- 처리량 - 주어진 시간 내에 종료된 프로세스의 개수
- 응답 시간 - 사용자의 요구에 대해 응답이 올 때까지의 시간이 짧아야 함
- 반환 시간 - 프로세스가 실행되기 시작해서 종료될 때까지의 시간이 짧아야 함
- 대기 시간 - 프로세스의 대기 시간이 짧아야 함
###대표적인 스케쥴링 3가지
- FCFS 스케쥴링
 - 먼저 도착한 프로세스를 먼저 실행하는 방법
 - 프로세스의 실행 순서에 따라 평균 대기 시간이 크게 차이 남
- 라운드 로빈 스케줄링
 - 여러 프로세스들이 CPU를 조금씩 돌아가며 할당받아 실행되는 방식, 리눅스를 포함한 대부분의 시스템에서 사용하는 방식
 - 프로세스들은 시간 할당량 동안 CPU를 할당받아 실행되는데, 이 시간 동안 실행이 종료되지 못하면 운영체제에 의해 준비 상태로 쫒겨냐고 준비 큐의 다음 프로세스가 CPU를 할당받아 실행
 - 프로세스의 시간 할당량이 크면 FCFS 스케줄링과 같게 되어 평균 대기 시간이 길어지게 되고, 매우 짧으면 문맥 전환이 자주 발생하므로 실행보다는 문맥 전환하는데 더 많은 시간을 소모 
 - 적절한 시간은 10~100밀리초 
- 우선순위 스케줄링
 - 가장 높은 우선순위의 프로세스에게 먼저 CPU를 할당하는 방법
 - 우선 순위가 낮은 프로세스는 매우 오랜 시간 동안 실행이 되지 않을 수도 있어서 에이징을 통해 일정 시간 실행되지 않으면 우선순위를 한 단계씩 높이는 방법을 사용
###리눅스 에서의 스케줄링 
- SCHED_FIFO, SCHED_RR, SCHED_OTHER 세 가지 스케줄링 방식 제공
 - SCHED_FIFO - FIFO 방식의 실시간 정책으로 우선순위가 더 높은 프로세스가 없는 한 자신이 원하는 동안 CPU를 사용
 - SCHED_RR - 라운드 로빈 방식의 실시간 정책으로 동일한 우선순위의 SCHED_RR 프로세스 사이에 공정하게 CPU 시간을 할당
 - SCHED_OTHER - 일반 프로세스에 대한 정책으로 시분할 방식으로 스케줄링
- 3가지 프로세스가 모두 있을 때에는 실시간 > 비실시간이 우선순위가 높으며, 실시간 중에서는 rt_priority 값이 클수록 우선순위를 갖는다.
- 비실시간은 실시간 프로세스가 모두 종료될 때까지는 실행되지 못함