#분산 서버 구축
- 대규모 분산 시스템을 구축하기 위한 실용적 예와 그 원칙들 (NEXON KOREA 이호규)

### Why? 분산 서버는 왜 필요한가?
- 왜 필요하게 되었을까?
 - 게임이 바뀌었다.
 - 유저들 세상과의 교류 심지어 하나의 공통 세상
- 무엇을 분산 해야 할까?
 - 분산이란? Machine의 하드웨어 부하를 분산
 - Machine의 부하 (Network Traffic, CPU, Memory)
 - Good : 기능의 분산을 통한 서비스 안정성 ex. 채팅서버 shutdown, but Game play는 가능함
 - Bad : 정보의 분산으로 디버깅의 어려움, 에러처리 복잡, 동시성 버그 파악의 어려움

### How? 어떻게 분산할 것인가?
- 분산서버의 기본 
- 기능 or 로직이 독립적으로 작동 
- 독립적 = 서로에게 영향을 주지 않음
- Scale Out 
 - A+B = C가 아니라 A A A
 - 주의할 점 : 통합 독립적 로직 vs 단순 기능 로직
- 기능로직 분리
 - 예외처리의 복잡함
 - Transaction처리의 복잡함
 - 로그 분석 복잡함
- 통합로직
 - 동시성 제어 용이
 - 버그 재현 및 수정에 용이
 - 개발 유지보수 용이
- Role로 분산, Scale Up 성능과 비용의 타협
- 어떻게 scale out을 하는지 : 비용 생각
 - 애매
 - 아주 빈번한 처리가 아님
 - 정보 분산 동기화 비용 너무 큼
 - 성능보단 안정성
 - >> 이런 경우 Scale Up이 좋다(장비빨)
- Database를 어떻게 scale out하는지
 - 왜 필요하게 되었을까? 대규모 Social Game을 생각해본다. (만, 십만 아닌 수백만명)
 - 게임서버는 Scale out, But DB는?
 - Database의 Scale Out : Sharding
- Sharding방법 
 - Mapping table
 - Dynamic share
- Mapping 
 - shard 정보를 테이블에 저장
 - Cache를 이용해 성능을 최적화
 - Mapping Table size ( 20byte*1 million = 20M )
 - Global DB의 부하 (Scale Up)??
- Dynamic
 - 기준 값을 key로 하여 Data 분산
 - 개발 구현이 쉬움
 - Static Sharding으로 인한 Re-Sharding 문제
- Sharding good But database transaction?
 - DB SQL에서가 아닌 Code 에서 처리
 - 병목
 - CPU : Pipe Line이 아니다. 병목 처리 주의
 - Memory : 64bit machine ( Win..2008 R2 En..) 최대물리 메모리 2TB, 각 분산서버 메모리 사용
 - I/O : 제일 느린 자원, DB I/O, Network I/O
 - DB I/O : Memory Update First, Data Validation From DB
 - Net I/O : 네트워크 라인 분리, 채팅 때문에 게임이 느려져서는 안된다.
 - Broadcast : 지불할 수 밖에 없는 비용, Grouping을 통한 최적화, 네트워크 라인 분리, 완벽한 최적화 < 90% + 장비
- Test
 - Machine 지표 : CPU, Memory, Network bound In/Out
 - Logic 지표 : Packet Queue 길이 -> Packet Handler, Logic Frame 처리 속도
 - Network 지표 : Network Latency, Send Queue data 크기
- 병목 : 전체적으로 게임이 느려짐? Scale out을 해도 개선이 안됨?
- 성능 : 단일서버의 성능 ( 동접등 )
- How
 - 장비 Spec 중요
 - Broadcast + 중요 Logic
 - ex) 대량사냥 + 대량로그인 / 로그아웃
- 서버성능
 - 비동기 I/O
 - Polling vs Event
 - 계산, 값 Cache
- Multi
 - Process or Thread
 - Process : I/O Multi thread, Single Logic Thread, 관리, 개발의 편리함
 - Thread : 멀티코어를 활용한 처리량 증대, Singleton 제약, Concurrent 버그 발생 위험

### What? 견고한 분산 서버 시스템이란? (지금은 잘 모르겠다. 나중에 다시 읽어보기)
- Solid 
 - Fault tolerance
 - User trace
 - Server Dashboard
- Fault
 - Exception Handling 
 - Failover
- Exceptione
 - Always Available
 - Graceful Exception Handling
 - Error Trace
- SEH, TryCatch
 - 예외처리를 통한 서비스 지속
 - Call Stack, dump를 통한 에러 추적
- Graceful
 - 단순 에러 처리 보단 친절 제공 
 - ex. 에러 메시지 표시 + 10초 후 로비
- Error Trace
 - Call Stack + Debug Log
 - Exception 발생시 기록한 일정수의
 - 휘발성 로그를 저장 (BlackBox)
- Failovere
 - Instant Load
 - Local DB, Memory DB
 - Replication
- Instant
 - 필요할 때 정보를 복구
 - 중요하지 않는 정보를 다를 때 유용
 - ex. 메일서버
- From DB
 - 시작될 때 필요정보 모두 Load
 - 복구 안정성 좋음
 - 서비스 시작 Delay, 정보기록 부하
 - ex. 매니저서버
- Replication
 - Master / Slave (Write 동기화)
 - 안정적인 복구 모델
 - 다수의 Slave를 통한 Read 부하분산
 - ex. DB서버, 매니저서버
- Dash Board
 - 특정 유저의 추적
 - 현재 분산서버 모니터
 - 지표 수집
- Log 
 - 파일 로그 < DB 로그
 - 검색이 용이
 - 일일 로그 ( DB 일별 테이블)
- Monitor
 - Memory DB( redis )를 이용
 - 성능지표( latency ) 
 - Warning ( exception, critical value)
- Indicator
 - 중요 지표( cs )는 서버에서
 - 게임 분석 지표는 client base log를 고려
- Client Base
 - 필요한 정보을 Client가 가지고 있음
 - 서버 로깅 부하와 분리 가능 ( Rabbit MQ )
 - 로그 작업의 편리( client 패치, 시점 )
 - Ex. 특정 레벨업 때의 장비 정보, 던전 입장시 파티원의 직업
- Redis
 - pub /sub을 통한 다양한 Admin
 - 공지사항, 특정 유저 알림
 - 실시간 event ( QA Live test )
 - 상점 on/off등 feature 관리 기능(제재기능)

- 출처 : http://www.slideshare.net/HoGyuLee/ndc14-abc, http://lacti.me/2014/05/28/ndc14-build-distributed-system/#comment-1483795001